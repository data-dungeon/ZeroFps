
///////////////////////////////////////////////////////////////////////////////
// BASIC_CONSOLE - START
///////////////////////////////////////////////////////////////////////////////

//#ifndef _BASIC_BASICCONSOLE_H_
//#define _BASIC_BASICCONSOLE_H_

//#include "os.h"
//#include "zfobject.h"
//#include "basic_x.h"
//#include <iostream>
//#include <vector>

//using namespace std;

#define TEXT_MAX_LENGHT 256

/*
 Basic console är ett object som kan ta in kommandon och skriva ut resultat 
 från användaren. 
*/
class /* BASIC_API */ BasicConsole : public ZFObject {
//protected:
//		vector<char*>	m_kText;

//public:
		BasicConsole(char* szName);
		
		// Print output to console.
		virtual void Print(const char* aText);
		//virtual void Printf(const char *fmt, ...);
		
		enum FuncId_e
			{
			FID_HELP
			};

		void RunCommand(int cmdid, const CmdArgument* kCommand);

};

//#endif

///////////////////////////////////////////////////////////////////////////////
// BASIC_CONSOLE - END
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// CONSOLE - START
///////////////////////////////////////////////////////////////////////////////

//#ifndef _CONSOLE_H_
//#define _CONSOLE_H_

//#include "../basic/basic.pkg"
//#include "../render/render.pkg"
//#include "input.h"
//#include "engine_x.h"
//#include <iostream>
//#include <vector>
//#include <deque>


//using namespace std;

//class Input;
//class ZeroFps;

//max lenght of an entered command
#define COMMAND_LENGHT 128

class /*ENGINE_API*/ Console : public BasicConsole {
//	private:
//		void FormatKey(int& r_iKey);
//		ZeroFps* m_pkEngine;		
//		CmdSystem* m_pkCmd;
//		Render* m_pkRender;
//		Input* m_pkInput;
//		TextureManager* m_pkTexMan;
		
//		SDL_Event m_kEvent;
//		char m_aCommand[TEXT_MAX_LENGHT];
//		int m_iBufferSize;
//		bool m_bShift;

//		unsigned int m_nStartLine;
//		const unsigned int MAX_CMD_HISTRORY_LENGTH;
//		unsigned int m_nLastCommand;
//		deque<string> m_kCommandHistory;
		

//	public:
		Console();
		
		void Update(void);
		bool Execute(char* aText);
};



//#endif

///////////////////////////////////////////////////////////////////////////////
// CONSOLE - END
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// VECTOR3 - START
///////////////////////////////////////////////////////////////////////////////

//#include <iostream>
//#include <cmath>
//#include "basic_x.h"
//#include "os.h"

//using namespace std;

/// A Class for vector math operations in 3D.
class /*BASIC_API*/ Vector3 {
//	public:
// Std Values
		static const Vector3 ZERO;									
		static const Vector3 AXIS_X;								
		static const Vector3 AXIS_Y;								
		static const Vector3 AXIS_Z;								
		static const float degtorad;

// Data
		float x;
		float y;
		float z;                                
	
// Metoder
		Vector3(float fX,float fY,float fZ);// { };
		Vector3();// { };											
/*
		// Assign
		Vector3& operator=(const Vector3 &kOtherV3); {
			x=kOtherV3.x;
			y=kOtherV3.y;
			z=kOtherV3.z;
			return *this;
			}	
			*/
/*
		void Set(float fXIn, float fYIn, float fZIn);  {
			x = fXIn;
			y = fYIn;
			z = fZIn;
			}

		float& operator[] (const int i);

		// Arithmetic operations
		Vector3 operator+(const Vector3 &kOtherV3);	const {
			return Vector3(x+kOtherV3.x,y+kOtherV3.y,z+kOtherV3.z);
			}

		Vector3 operator+(const float &fAdd);		const {
			return Vector3(x+fAdd,y+fAdd,z+fAdd);
			}

		Vector3 operator-(const Vector3 &kOtherV3);	const {
			return Vector3(x-kOtherV3.x,y-kOtherV3.y,z-kOtherV3.z);
			}

		Vector3 operator-(const float &fAdd);		const {
			return Vector3(x-fAdd,y-fAdd,z-fAdd);
			}

		Vector3 operator*(const float &fOther);		const {
			return Vector3(x * fOther,y * fOther,z * fOther);
			}
		
		Vector3 operator*(const Vector3 &fOther)		const {
			return Vector3(x * fOther.x,y * fOther.y,z * fOther.z);
			}
		
//		Vector3 operator*(const Matrix4 &f)	const;
	
	
		Vector3 operator /  ( const float  s )	 const {
			float invs = 1/s; 
			return Vector3( invs*x, invs*y, invs*z );
		}

		Vector3& operator+=(const Vector3 &kOtherV3)  {
			x += kOtherV3.x;
			y += kOtherV3.y;
			z += kOtherV3.z;
			return *this;
			}

		Vector3& operator-=(const Vector3 &kOtherV3)  {
			x -= kOtherV3.x;
			y -= kOtherV3.y;
			z -= kOtherV3.z;
			return *this;
			}

		Vector3& operator*=(const float &fOther)  {
			x *= fOther;
			y *= fOther;
			z *= fOther;
			return *this;
			}

		Vector3& operator/=(const float fOther) {
			x /= fOther;
			y /= fOther;
			z /= fOther;
			return *this;
			}

		Vector3& operator /= ( const float& s )					
		//{
		//	float r = 1 / s; x *= r; y *= r; z *= r; 
		//	return *this; 
		//}

		Vector3 operator-() {
		//	return Vector3(-x,-y,-z);
		//	}

		// Comparison
		// bool operator==(const Vector3 &kOtherV3)	const;			// NC	NO SUPPORT IN LUA
		// bool operator!=(const Vector3 &kOtherV3)	const;			// NC	NO SUPPORT IN LUA

	*/

		// Vector operations.
		float Length(void);// const {
		//	return (float) sqrt( x*x + y*y + z*z );  
		//	}

		// Squared length of vector.
		float LengthSqr(void);// const {
		//	return (float)( x*x + y*y + z*z );  
		//	}

		// Returns squaredlength length of vector.
		float SquaredLength(void);// const {
		//	return x*x + y*y +z*z;  
		//	}

		void Normalize(void);										///< Normalize this to unit vector.
		float Dot( const Vector3& v  )		const; 					///< Return dot product between this vec and another one.
		Vector3 Unit(void)					const;					///< Return unit vector of this.		
		Vector3 Cross( const Vector3& v )	const;					///< Return cross product between this vector and another one.
		
	
		bool IsZero(void) const;									///< True if this = <0,0,0>
		bool NearlyEquals( const Vector3& v, const float e ) const;	///< True if this is == v within the range of +-e
		bool NearlyZero( const float e ) const; 					///< True if this is <0,0,0> within the range of +-e
		
		Vector3 Proj( Vector3& v );									///< Projects v on this.
		Vector3 Perp( Vector3& v );									///< Perp v on this.
		float Angle( Vector3& v );									///< Angle (in rad) between two vectors. 
		void Abs(void);												///< Do a fabs() on coo of this vectors.
		int	AbsMaxCoo(void);										///< Returns Index för den coo med > fabs(value).
		void Lerp(Vector3& from, Vector3& to, float flerp);			///< Linjär interpolering mellan två vectors.
		
		Vector3 Angels(void);
		Vector3 AToU();												///< convert Angel Vector to a Unit Vector

		void Print(void);

};

/*BASIC_API */ // Vector3 operator * ( const float& s, const Vector3& v );

///////////////////////////////////////////////////////////////////////////////
// VECTOR3 - END
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// EngineScriptInterface - START
///////////////////////////////////////////////////////////////////////////////

//#include "engine_x.h"

//class Object;

enum OBJECT_TYPE
{
	ObjTypeSelf,		
	ObjTypeCreature,
	ObjTypeDoor,
	ObjTypeItem,
	ObjTypeNone
};

typedef int OBJECT; // same as network id

class /*ENGINE_API*/ EngineScriptInterface
{

// Export functions:
//public:
	EngineScriptInterface();
	virtual ~EngineScriptInterface();

	/// Recives the position for the object.
	Vector3 GetObjectPos(OBJECT obj);
	
	/// Recives the first-person-player for the client.
	OBJECT GetPlayer();

	/// Recives the closes object from kFocusObj or -1 if no object exist,
	/// or if kFocusObj doesn´t exist.
	OBJECT GetClosestObject(OBJECT kFocusObj);

	/// Recives the closes hostile object from kFocusObj or -1 if no object exist,
	/// or if kFocusObj doesn´t exist.
	OBJECT GetClosestEnemy(OBJECT kFocusObj);

	/// Recives the type of obj (or -1 if obj doesn´t exist)
	OBJECT_TYPE GetObjectType(OBJECT obj);

	/// Recives rhe distance in meters between two objects or -1 if either of the 
	/// two objects doesn´t exist.
	float GetMetersBetween(OBJECT obj1, OBJECT obj2);

	void DestroyObject(int obj);

// Internal functions:
//private:
//	ObjectManager* m_pkObjMan;
//	Object* GetObject(int iNetworkID);
};

///////////////////////////////////////////////////////////////////////////////
// EngineScriptInterface - END
///////////////////////////////////////////////////////////////////////////////